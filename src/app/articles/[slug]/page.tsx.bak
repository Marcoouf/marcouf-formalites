import { notFound } from 'next/navigation'
import { compileMDX } from 'next-mdx-remote/rsc'
import remarkGfm from 'remark-gfm'
import readingTime from 'reading-time'
import rehypeSlug from 'rehype-slug'
import rehypeAutolinkHeadings from 'rehype-autolink-headings'
import { getAllSlugs, getArticleBySlug } from '../../../lib/articles'

function formatFR(dateISO?: string) {
  if (!dateISO) return null
  try {
    const iso = dateISO.length === 10 ? `${dateISO}T00:00:00Z` : dateISO
    const d = new Date(iso)
    return new Intl.DateTimeFormat('fr-FR', { timeZone: 'UTC' }).format(d)
  } catch {
    return dateISO
  }
}

function stripMarkdown(s: string) {
  return s
    .replace(/```[\s\S]*?```/g, '')
    .replace(/`[^`]*`/g, '')
    .replace(/!\[[^\]]*\]\([^\)]+\)/g, '')
    .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')
    .replace(/^[>\s]*[-*+]\s+/gm, '')
    .replace(/^[>\s]*\d+\.\s+/gm, '')
    .replace(/[*_#>~`]/g, '')
    .replace(/\n{2,}/g, '\n')
    .trim()
}

function stripLeadingH1(md: string, metaTitle?: string) {
  const m = md.match(/^\s*#\s+([^\n]+)\s*\n/);
  if (!m) return md;
  const first = m[1].trim();
  const norm = (s: string) => s.toLowerCase().replace(/[\s'’"()?:!.,;-]+/g, '');
  // On supprime le H1 s’il est identique au titre (normalisé)
  if (!metaTitle || norm(first) === norm(metaTitle)) {
    return md.replace(/^\s*#\s+[^\n]+\s*\n/, '');
  }
  return md;
}

function extractFaqPairs(md: string): { q: string; a: string }[] {
  const start = md.search(/^##\s+FAQ\b.*$/m)
  if (start === -1) return []
  const after = md.slice(start)
  const idxAfterEol = after.indexOf('\n')
  const body = idxAfterEol === -1 ? '' : after.slice(idxAfterEol + 1)
  const nextH2 = body.search(/\n##\s+/)
  const section = nextH2 === -1 ? body : body.slice(0, nextH2)

  const pairs: { q: string; a: string }[] = []

  // Pattern 1: ### Question + answer until next heading
  const reH3 = /(^|\n)###\s+(.+?)\s*\n([\s\S]*?)(?=\n###\s+|\n##\s+|$)/g
  let m: RegExpExecArray | null
  while ((m = reH3.exec(section)) !== null) {
    const q = m[2].trim()
    const a = stripMarkdown(m[3])
    if (q && a) pairs.push({ q, a })
  }

  // Pattern 2: **Question** then answer paragraph(s)
  const reBold = /(^|\n)\*\*(.+?)\*\*\s*\n([\s\S]*?)(?=\n\*\*|\n###\s+|\n##\s+|$)/g
  while ((m = reBold.exec(section)) !== null) {
    const q = m[2].trim()
    const a = stripMarkdown(m[3])
    if (q && a) pairs.push({ q, a })
  }

  // Deduplicate by question text
  const seen = new Set<string>()
  return pairs.filter((p) => {
    if (seen.has(p.q)) return false
    seen.add(p.q)
    return true
  })
}

export async function generateStaticParams() {
  const slugs = await getAllSlugs()
  return slugs.map((slug) => ({ slug }))
}

export async function generateMetadata({ params }: { params: { slug: string } }) {
  const got = await getArticleBySlug(params.slug).catch(() => null)
  if (!got) return {}
  const { meta } = got
  return {
    title: meta.title,
    description: meta.description,
    alternates: { canonical: `/articles/${meta.slug}` },
    openGraph: {
      title: meta.title,
      description: meta.description,
      url: `https://www.marcouf-formalites.fr/articles/${meta.slug}`,
      type: 'article',
    },
  }
}

export default async function ArticlePage({ params }: { params: { slug: string } }) {
  const got = await getArticleBySlug(params.slug).catch(() => null)
  if (!got) return notFound()
  const { meta, content } = got

  const stats = readingTime(content)
  const readText = stats.text.replace('min read', 'min de lecture').replace('read', 'de lecture')
  const faqPairs = extractFaqPairs(content)

  const sourceForMDX = stripLeadingH1(content, meta.title)

const { content: MDXContent } = await compileMDX({
  source: sourceForMDX,
  options: {
    mdxOptions: {
      remarkPlugins: [remarkGfm],
      rehypePlugins: [
        rehypeSlug,
        [rehypeAutolinkHeadings, { behavior: 'append' }],
      ],
    },
  },
})

  return (
    <main className="mx-auto max-w-6xl px-6 sm:px-16 py-16 space-y-12">
      <header className="space-y-2">
        <h1 className="text-3xl md:text-4xl font-extrabold">{meta.title}</h1>
        {meta.description && <p className="text-gray-600">{meta.description}</p>}
        <div className="text-sm text-gray-500" suppressHydrationWarning>
          {meta.publishedAt && (
            <time dateTime={meta.publishedAt}>Publié le {formatFR(meta.publishedAt)}</time>
          )}
          {meta.updatedAt && meta.updatedAt !== meta.publishedAt && (
            <span> — Mis à jour le {formatFR(meta.updatedAt)}</span>
          )}
          <span> • </span>
          <span>{readText}</span>
        </div>
      </header>

      {/* ⬇️ Important : {MDXContent} (pas <MDXContent />) et stylé avec prose */}
      <div className="grid grid-cols-12 gap-8">
        <article
          className="
            col-span-12 lg:col-span-8 lg:col-start-3
            prose prose-neutral md:prose-lg
            prose-a:text-green-700 hover:prose-a:underline
            prose-headings:scroll-mt-24 prose-h2:mt-10
            prose-img:rounded-xl prose-hr:my-10
            prose-code:bg-gray-100 prose-code:px-1 prose-code:rounded
            bg-white border border-gray-200 rounded-2xl shadow-sm p-6 md:p-8
          "
        >
          {MDXContent}
        </article>
      </div>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify({
            '@context': 'https://schema.org',
            '@type': 'Article',
            headline: meta.title,
            description: meta.description,
            datePublished: meta.publishedAt,
            dateModified: meta.updatedAt || meta.publishedAt,
            author: { '@type': 'Organization', name: 'Marcouf Formalités' },
            publisher: { '@type': 'Organization', name: 'Marcouf Formalités' },
            mainEntityOfPage: {
              '@type': 'WebPage',
              '@id': `https://www.marcouf-formalites.fr/articles/${meta.slug ?? params.slug}`,
            },
          }),
        }}
      />
      {faqPairs.length > 0 && (
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{
            __html: JSON.stringify({
              '@context': 'https://schema.org',
              '@type': 'FAQPage',
              mainEntity: faqPairs.map(({ q, a }) => ({
                '@type': 'Question',
                name: q,
                acceptedAnswer: { '@type': 'Answer', text: a },
              })),
            }),
          }}
        />
      )}
    </main>
  )
}